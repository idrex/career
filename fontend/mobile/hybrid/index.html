<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.svg" />
    <link rel="stylesheet" href="/umi.css" />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.2.28
    </script>
    <title>Hybrid APP</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.svg&#x27;)" href="/">Drex</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/guide">指南</a><a aria-current="page" class="active" href="/fontend">前端</a><a href="/backend">后端</a><a href="/devops">运维</a><a href="/blog">博客</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/idrex/career">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.svg&#x27;)" href="/"></a><h1>Drex</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/guide">指南</a></li><li><a aria-current="page" class="active" href="/fontend">前端</a></li><li><a href="/backend">后端</a></li><li><a href="/devops">运维</a></li><li><a href="/blog">博客</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/idrex/career">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/fontend">前端体系图</a></li><li><a href="/fontend/browser">浏览器</a><ul><li><a href="/fontend/browser/basic"><span>基础知识</span></a></li><li><a href="/fontend/browser/model"><span>浏览器模型</span></a></li><li><a href="/fontend/browser/optimization"><span>性能优化</span></a></li><li><a href="/fontend/browser/request"><span>网络请求</span></a></li></ul></li><li><a href="/fontend/html">Html</a><ul><li><a href="/fontend/html/basic"><span>基础知识</span></a></li></ul></li><li><a href="/fontend/css">CSS</a><ul><li><a href="/fontend/css/basic"><span>基础知识</span></a></li><li><a href="/fontend/css/less"><span>Less</span></a></li></ul></li><li><a href="/fontend/javasrcipt">Javasrcipt</a><ul><li><a href="/fontend/javasrcipt/basic"><span>基础中的基础</span></a></li><li><a href="/fontend/javasrcipt/application"><span>基础应用</span></a></li><li><a href="/fontend/javasrcipt/esnext"><span>ES6 &amp; ES Next</span></a></li><li><a href="/fontend/javasrcipt/ts"><span>TypeScript</span></a></li><li><a href="/fontend/javasrcipt/issues"><span>JS 相关方法实现</span></a></li><li><a href="/fontend/javasrcipt/optimization"><span>代码优化技巧</span></a></li></ul></li><li><a href="/fontend/construct">构建工具</a><ul><li><a href="/fontend/construct/webpack"><span>Webpack</span></a></li></ul></li><li><a href="/fontend/frame">JS 框架</a><ul><li><a href="/fontend/frame/react"><span>React</span></a></li><li><a href="/fontend/frame/redux"><span>Redux</span></a></li><li><a href="/fontend/frame/vue"><span>Vue</span></a></li></ul></li><li><a aria-current="page" class="active" href="/fontend/mobile">移动&amp;桌面应用</a><ul><li><a href="/fontend/mobile/certificate"><span>证书说明</span></a></li><li><a aria-current="page" class="active" href="/fontend/mobile/hybrid"><span>Hybrid APP</span></a></li><li><a href="/fontend/mobile/react-native"><span>React Native</span></a></li></ul></li><li><a href="/fontend/setup">工程体系</a><ul><li><a href="/fontend/setup/pattern"><span>体系格局</span></a></li><li><a href="/fontend/setup/engineering"><span>前端工程化</span></a></li></ul></li><li><a href="/fontend/package">Package</a><ul><li><a href="/fontend/package/module"><span>模块化标准</span></a></li><li><a href="/fontend/package/npm"><span>Npm</span></a></li><li><a href="/fontend/package/yarn"><span>Yarn</span></a></li></ul></li><li><a href="/fontend/security">Security</a><ul><li><a href="/fontend/security/monitor"><span>监控体系</span></a></li><li><a href="/fontend/security/web"><span>Web 安全</span></a></li></ul></li><li><a href="/fontend/visual">Visual</a><ul><li><a href="/fontend/visual/map"><span>Map 地图组建</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="混合方案简析" data-depth="2" class=""><a href="/fontend/mobile/hybrid#混合方案简析"><span>混合方案简析</span></a></li><li title="Webview UI" data-depth="3" class=""><a href="/fontend/mobile/hybrid#webview-ui"><span>Webview UI</span></a></li><li title="Native UI" data-depth="3" class=""><a href="/fontend/mobile/hybrid#native-ui"><span>Native UI</span></a></li><li title="小程序" data-depth="3" class=""><a href="/fontend/mobile/hybrid#小程序"><span>小程序</span></a></li><li title="Webviev" data-depth="2" class=""><a href="/fontend/mobile/hybrid#webviev"><span>Webviev</span></a></li><li title="交互原理" data-depth="2" class=""><a href="/fontend/mobile/hybrid#交互原理"><span>交互原理</span></a></li><li title="JavaScript 通知 Native" data-depth="3" class=""><a href="/fontend/mobile/hybrid#javascript-通知-native"><span>JavaScript 通知 Native</span></a></li><li title="Native 通知 Javascript" data-depth="3" class=""><a href="/fontend/mobile/hybrid#native-通知-javascript"><span>Native 通知 Javascript</span></a></li><li title="接入方案" data-depth="2" class=""><a href="/fontend/mobile/hybrid#接入方案"><span>接入方案</span></a></li><li title="接入方式" data-depth="3" class=""><a href="/fontend/mobile/hybrid#接入方式"><span>接入方式</span></a></li><li title="优化方案简述" data-depth="2" class=""><a href="/fontend/mobile/hybrid#优化方案简述"><span>优化方案简述</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="hybrid-app"><a aria-hidden="true" href="#hybrid-app"><span class="icon icon-link"></span></a>Hybrid APP</h1><p>随着 Web技术 和 移动设备 的快速发展，在各家大厂中，Hybrid 技术已经成为一种最主流最不可取代的架构方案之一。一套好的 Hybrid 架构方案能让 App 既能拥有 <strong>极致的体验和性能</strong>，同时也能拥有 Web技术 <strong>灵活的开发模式、跨平台能力以及热更新机制</strong>。因此，相关的 Hybrid 领域人才也是十分的吃香，精通Hybrid 技术和相关的实战经验，也是面试中一项大大的加分项。</p><h2 id="混合方案简析"><a aria-hidden="true" href="#混合方案简析"><span class="icon icon-link"></span></a>混合方案简析</h2><p>Hybrid App，俗称 <strong>混合应用</strong>，即混合了 Native技术 与 Web技术 进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在UI渲染机制上的不同: </p><h3 id="webview-ui"><a aria-hidden="true" href="#webview-ui"><span class="icon icon-link"></span></a>Webview UI</h3><ul><li>通过 JSBridge 完成 H5 与 Native 的双向通讯，并 <strong>基于 Webview</strong> 进行页面的渲染；</li><li><strong>优势</strong>: 简单易用，架构门槛/成本较低，适用性与灵活性极强；</li><li><strong>劣势</strong>: Webview 性能局限，在复杂页面中，表现远不如原生页面；</li></ul><h3 id="native-ui"><a aria-hidden="true" href="#native-ui"><span class="icon icon-link"></span></a>Native UI</h3><ul><li>通过 JSBridge 赋予 H5 原生能力，并进一步将 JS 生成的虚拟节点树(Virtual DOM)传递至 Native 层，并使用 <strong>原生系统渲染</strong>。</li><li><strong>优势</strong>: 用户体验基本接近原生，且能发挥 Web技术 开发灵活与易更新的特性；</li><li><strong>劣势</strong>: 上手/改造门槛较高，最好需要掌握一定程度的客户端技术。相比于常规 Web开发，需要更高的开发调试、问题排查成本；</li></ul><h3 id="小程序"><a aria-hidden="true" href="#小程序"><span class="icon icon-link"></span></a>小程序</h3><ul><li>通过更加定制化的 JSBridge，赋予了 Web 更大的权限，并使用双 WebView 双线程的模式隔离了 JS逻辑 与 UI渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，属于第一种方案的优化版本；</li><li><strong>优势</strong>: 用户体验好于常规 Webview 方案，且通常依托的平台也能提供更为友好的开发调试体验以及功能；</li><li><strong>劣势</strong>: 需要依托于特定的平台的规范限定</li></ul><h2 id="webviev"><a aria-hidden="true" href="#webviev"><span class="icon icon-link"></span></a>Webviev</h2><p>Webview 是 Native App 中内置的一款基于 Webkit内核 的浏览器，主要由两部分组成:</p><ul><li><strong>WebCore 排版引擎</strong>；</li><li><strong>JSCore 解析引擎</strong>；</li></ul><p>在原生开发 SDK 中 Webview 被封装成了一个组件，用于作为 Web页面 的容器。因此，作为宿主的客户端中拥有更高的权限，可以对 Webview 中的 Web页面 进行配置和开发。</p><p>Hybrid技术中双端的交互原理，便是基于 Webview 的一些 API 和特性。</p><h2 id="交互原理"><a aria-hidden="true" href="#交互原理"><span class="icon icon-link"></span></a>交互原理</h2><p>Hybrid技术 中最核心的点就是 Native端 与 H5端 之间的 <strong>双向通讯层</strong>，其实这里也可以理解为我们需要一套 <strong>跨语言通讯方案</strong>，便是我们常听到的 JSBridge。</p><h3 id="javascript-通知-native"><a aria-hidden="true" href="#javascript-通知-native"><span class="icon icon-link"></span></a>JavaScript 通知 Native</h3><ul><li><strong>API注入</strong>，Native 直接在 JS 上下文中挂载数据或者方法<ul><li>延迟较低，在安卓4.1以下具有安全性问题，风险较高 </li></ul></li><li>WebView <strong>URL Scheme</strong> 跳转拦截<ul><li>兼容性好，但延迟较高，且有长度限制 </li></ul></li><li>WebView 中的 <strong>prompt/console/alert拦截</strong>(通常使用 prompt)</li></ul><h3 id="native-通知-javascript"><a aria-hidden="true" href="#native-通知-javascript"><span class="icon icon-link"></span></a>Native 通知 Javascript</h3><ul><li><strong>IOS</strong>: <code>stringByEvaluatingJavaScriptFromString</code></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// Swift
webview.stringByEvaluatingJavaScriptFromString(&quot;alert(&#x27;NativeCall&#x27;)&quot;)
" data-status="copy"></button><div class="token-line"><span class="token comment">// Swift</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">webview</span><span class="token punctuation">.</span><span class="token method function property-access">stringByEvaluatingJavaScriptFromString</span><span class="token punctuation">(</span><span class="token string">&quot;alert(&#x27;NativeCall&#x27;)&quot;</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><ul><li><strong>Android</strong>: <code>loadUrl</code> (4.4-)  </li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// 调用js中的JSBridge.trigger方法
// 该方法的弊端是无法获取函数返回值；
webView.loadUrl(&quot;javascript:JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;)
" data-status="copy"></button><div class="token-line"><span class="token comment">// 调用js中的JSBridge.trigger方法</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 该方法的弊端是无法获取函数返回值；</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">webView</span><span class="token punctuation">.</span><span class="token method function property-access">loadUrl</span><span class="token punctuation">(</span><span class="token string">&quot;javascript:JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><ul><li><strong>Android</strong>: <code>evaluateJavascript</code> (4.4+)</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// 4.4+后使用该方法便可调用并获取函数返回值；
mWebView.evaluateJavascript（&quot;javascript:JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;,    new ValueCallback&lt;String&gt;() {
    @Override
    public void onReceiveValue(String value) {
        //此处为 js 返回的结果
    }
});
" data-status="copy"></button><div class="token-line"><span class="token comment">// 4.4+后使用该方法便可调用并获取函数返回值；</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">mWebView</span><span class="token punctuation">.</span><span class="token property-access">evaluateJavascript（</span><span class="token string">&quot;javascript:JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;</span><span class="token punctuation">,</span><span class="token plain">    </span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">ValueCallback</span><span class="token operator">&lt;</span><span class="token known-class-name class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    @</span><span class="token maybe-class-name">Override</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">public</span><span class="token plain"> </span><span class="token keyword">void</span><span class="token plain"> </span><span class="token function">onReceiveValue</span><span class="token punctuation">(</span><span class="token parameter">String value</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token comment">//此处为 js 返回的结果</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h2 id="接入方案"><a aria-hidden="true" href="#接入方案"><span class="icon icon-link"></span></a>接入方案</h2><p>整套方案需要 Web 与 Native 两部分共同来完成:</p><ul><li><strong>Native</strong>: 负责实现URL拦截与解析、环境信息的注入、拓展功能的映射、版本更新等功能；</li><li><strong>JavaScirpt</strong>: 负责实现功能协议的拼装、协议的发送、参数的传递、回调等一系列基础功能。</li></ul><h3 id="接入方式"><a aria-hidden="true" href="#接入方式"><span class="icon icon-link"></span></a>接入方式</h3><ul><li><strong>在线H5</strong>: 直接将项目部署于线上服务器，并由客户端在 HTML 头部注入对应的 Bridge。<ul><li><strong>优势</strong>: 接入/开发成本低，对 App 的侵入小；</li><li><strong>劣势</strong>: 重度依赖网络，无法离线使用，首屏加载慢；</li></ul></li><li><strong>内置离线包</strong>: 将代码直接内置于 App 中，即本地存储中，可由 H5 或者 客户端引用 Bridge。<ul><li><strong>优势</strong>: 首屏加载快，可离线化使用；</li><li><strong>劣势</strong>: 开发、调试成本变高，需要多端合作，且会增加 App 包体积</li></ul></li></ul><h2 id="优化方案简述"><a aria-hidden="true" href="#优化方案简述"><span class="icon icon-link"></span></a>优化方案简述</h2><ul><li><p><strong>Webview 预加载</strong>: Webview 的初始化其实挺耗时的。我们测试过，大概在100~200ms之间，因此如果能前置做好初始化于内存中，会大大加快渲染速度。</p></li><li><p><strong>更新机制</strong>: 使用离线包的时候，便会涉及到本地离线代码的更新问题，因此需要建立一套云端下发包的机制，由客户端下载云端最新代码包 (zip包)，并解压替换本地代码。</p><ul><li><p><strong>增量更新</strong>: 由于下发包是一个下载的过程，因此包的体积越小，下载速度越快，流量损耗越低。只打包改变的文件，客户端下载后覆盖式替换，能大大减小每次更新包的体积。</p></li><li><p><strong>条件分发</strong>: 云平台下发更新包时，可以配合客户端设置一系列的条件与规则，从而实现代码的条件更新:</p><ol><li>单 <strong>地区</strong> 更新: 例如一个只有中国地区才能更新的版本；</li><li>按 <strong>语言</strong> 更新: 例如只有中文版本会更新；</li><li>按 App <strong>版本</strong> 更新: 例如只有最新版本的 App 才会更新；</li><li><strong>灰度</strong> 更新: 只有小比例用户会更新；</li><li><strong>AB测试</strong>: 只有命中的用户会更新；</li></ol></li></ul></li><li><p><strong>降级机制</strong>: 当用户下载或解压代码包失败时，需要有套降级方案，通常有两种做法: </p><ul><li><strong>本地内置</strong>: 随着 App 打包时内置一份线上最新完整代码包，保证本地代码文件的存在，资源加载均使用本地化路径；</li><li><strong>域名拦截</strong>: 资源加载使用线上域名，通过拦截域名映射到本地路径。当本地不存在时，则请求线上文件，当存在时，直接加载；</li></ul></li><li><p><strong>跨平台部署</strong>: Bridge层 可以做一套浏览器适配，在一些无法适配的功能，做好降级处理，从而保证代码在任何环境的可用性，一套代码可同时运行于 App内 与 普通浏览器；</p></li><li><p><strong>环境系统</strong>: 与客户端进行统一配合，搭建出 <strong>正式 / 预上线 / 测试 / 开发</strong>环境，能大大提高项目稳定性与问题排查；</p></li><li><p><strong>开发模式</strong>: </p><ul><li>能连接PC Chrome/safari 进行代码调试；</li><li>具有开发调试入口，可以使用同样的 Webview 加载开发时的本地代码；</li><li>具备日志系统，可以查看 Log 信息；</li></ul></li></ul><p>详细内容由兴趣的童鞋可以看文章: </p><ul><li><a href="https://github.com/xd-tayde/blog/blob/master/hybrid-1.md" target="_blank" rel="noopener noreferrer">Hybrid App技术解析 -- 原理篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://github.com/xd-tayde/blog/blob/master/hybrid-2.md" target="_blank" rel="noopener noreferrer">Hybrid App技术解析 -- 实战篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><span data-updated-text="Last Update: ">11/27/2020, 9:47:03 AM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/umi.js"></script>
  </body>
</html>
