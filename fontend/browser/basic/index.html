<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.svg" />
    <link rel="stylesheet" href="/umi.css" />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.2.14
    </script>
    <title>&#x57FA;&#x7840;&#x77E5;&#x8BC6;</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.svg&#x27;)" href="/">Drex</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><a href="/guide">指南</a><a aria-current="page" class="active" href="/fontend">前端</a><a href="/backend">后端</a><a href="/devops">运维</a><a href="/blog">博客</a><a target="_blank" rel="noopener noreferrer" href="https://github.com/idrex/career">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.svg&#x27;)" href="/"></a><h1>Drex</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/guide">指南</a></li><li><a aria-current="page" class="active" href="/fontend">前端</a></li><li><a href="/backend">后端</a></li><li><a href="/devops">运维</a></li><li><a href="/blog">博客</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/idrex/career">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/fontend">前端体系图</a></li><li><a aria-current="page" class="active" href="/fontend/browser">浏览器</a><ul><li><a aria-current="page" class="active" href="/fontend/browser/basic"><span>基础知识</span></a></li><li><a href="/fontend/browser/model"><span>浏览器模型</span></a></li><li><a href="/fontend/browser/optimization"><span>性能优化</span></a></li><li><a href="/fontend/browser/request"><span>网络请求</span></a></li></ul></li><li><a href="/fontend/html">Html</a><ul><li><a href="/fontend/html/basic"><span>基础知识</span></a></li></ul></li><li><a href="/fontend/css">CSS</a><ul><li><a href="/fontend/css/basic"><span>基础知识</span></a></li><li><a href="/fontend/css/less"><span>Less</span></a></li></ul></li><li><a href="/fontend/javasrcipt">Javasrcipt</a><ul><li><a href="/fontend/javasrcipt/basic"><span>基础中的基础</span></a></li><li><a href="/fontend/javasrcipt/application"><span>基础应用</span></a></li><li><a href="/fontend/javasrcipt/esnext"><span>ES6 &amp; ES Next</span></a></li><li><a href="/fontend/javasrcipt/ts"><span>TypeScript</span></a></li><li><a href="/fontend/javasrcipt/issues"><span>JS 相关方法实现</span></a></li><li><a href="/fontend/javasrcipt/optimization"><span>代码优化技巧</span></a></li></ul></li><li><a href="/fontend/construct">构建工具</a><ul><li><a href="/fontend/construct/webpack"><span>Webpack</span></a></li></ul></li><li><a href="/fontend/frame">JS 框架</a><ul><li><a href="/fontend/frame/react"><span>React</span></a></li><li><a href="/fontend/frame/redux"><span>Redux</span></a></li><li><a href="/fontend/frame/vue"><span>Vue</span></a></li></ul></li><li><a href="/fontend/mobile">移动&amp;桌面应用</a><ul><li><a href="/fontend/mobile/certificate"><span>证书说明</span></a></li><li><a href="/fontend/mobile/hybrid"><span>Hybrid APP</span></a></li><li><a href="/fontend/mobile/react-native"><span>React Native</span></a></li></ul></li><li><a href="/fontend/setup">工程体系</a><ul><li><a href="/fontend/setup/pattern"><span>体系格局</span></a></li><li><a href="/fontend/setup/engineering"><span>前端工程化</span></a></li></ul></li><li><a href="/fontend/package">Package</a><ul><li><a href="/fontend/package/module"><span>模块化标准</span></a></li><li><a href="/fontend/package/npm"><span>Npm</span></a></li><li><a href="/fontend/package/yarn"><span>Yarn</span></a></li></ul></li><li><a href="/fontend/security">Security</a><ul><li><a href="/fontend/security/monitor"><span>监控体系</span></a></li><li><a href="/fontend/security/web"><span>Web 安全</span></a></li></ul></li></ul></div></div><ul class="__dumi-default-layout-toc" role="slug-list"><li title="浏览器架构" data-depth="2" class=""><a href="/fontend/browser/basic#浏览器架构"><span>浏览器架构</span></a></li><li title="浏览器下事件循环(Event Loop)" data-depth="2" class=""><a href="/fontend/browser/basic#浏览器下事件循环event-loop"><span>浏览器下事件循环(Event Loop)</span></a></li><li title="从输入 url 到展示的过程" data-depth="2" class=""><a href="/fontend/browser/basic#从输入-url-到展示的过程"><span>从输入 url 到展示的过程</span></a></li><li title="重绘与回流" data-depth="2" class=""><a href="/fontend/browser/basic#重绘与回流"><span>重绘与回流</span></a></li><li title="最佳实践:" data-depth="3" class=""><a href="/fontend/browser/basic#最佳实践"><span>最佳实践:</span></a></li><li title="存储" data-depth="2" class=""><a href="/fontend/browser/basic#存储"><span>存储</span></a></li><li title="cookie属性" data-depth="3" class=""><a href="/fontend/browser/basic#cookie属性"><span>cookie属性</span></a></li><li title="缓存" data-depth="2" class=""><a href="/fontend/browser/basic#缓存"><span>缓存</span></a></li><li title="强制缓存" data-depth="3" class=""><a href="/fontend/browser/basic#强制缓存"><span>强制缓存</span></a></li><li title="协商缓存" data-depth="3" class=""><a href="/fontend/browser/basic#协商缓存"><span>协商缓存</span></a></li><li title="浏览器缓存过程" data-depth="3" class=""><a href="/fontend/browser/basic#浏览器缓存过程"><span>浏览器缓存过程</span></a></li><li title="Web Worker" data-depth="2" class=""><a href="/fontend/browser/basic#web-worker"><span>Web Worker</span></a></li><li title="跨标签页通讯" data-depth="2" class=""><a href="/fontend/browser/basic#跨标签页通讯"><span>跨标签页通讯</span></a></li><li title="V8垃圾回收机制" data-depth="2" class=""><a href="/fontend/browser/basic#v8垃圾回收机制"><span>V8垃圾回收机制</span></a></li><li title="内存泄露" data-depth="2" class=""><a href="/fontend/browser/basic#内存泄露"><span>内存泄露</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h2 id="浏览器架构"><a aria-hidden="true" href="#浏览器架构"><span class="icon icon-link"></span></a>浏览器架构</h2><ul><li>用户界面</li><li>主进程 </li><li>内核<ul><li>渲染引擎</li><li>JS 引擎<ul><li>执行栈 </li></ul></li><li>事件触发线程<ul><li>消息队列<ul><li>微任务</li><li>宏任务  </li></ul></li></ul></li><li>网络异步线程</li><li>定时器线程</li></ul></li></ul><h2 id="浏览器下事件循环event-loop"><a aria-hidden="true" href="#浏览器下事件循环event-loop"><span class="icon icon-link"></span></a>浏览器下事件循环(Event Loop)</h2><p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表 </p><ul><li>微任务 <code>microtask(jobs)</code>: <code>promise / ajax / Object.observe(该方法已废弃)</code></li><li>宏任务 <code>macrotask(task)</code>: <code>setTimout / script / IO / UI Rendering</code></li></ul><h2 id="从输入-url-到展示的过程"><a aria-hidden="true" href="#从输入-url-到展示的过程"><span class="icon icon-link"></span></a>从输入 url 到展示的过程</h2><ul><li>DNS 解析 </li><li>TCP 三次握手</li><li>发送请求，分析 url，设置请求报文(头，主体)</li><li>服务器返回请求的文件 (html)</li><li>浏览器渲染<ul><li><code>HTML parser</code> =&gt; <code>DOM Tree</code><ul><li>标记化算法，进行元素状态的标记</li><li>dom 树构建 </li></ul></li><li><code>CSS parser</code> =&gt; <code>Style Tree</code><ul><li>解析 css 代码，生成样式树 </li></ul></li><li>attachment =&gt; <code>Render Tree</code><ul><li>结合 dom树 与 style树，生成渲染树</li></ul></li><li>layout: 布局</li><li>GPU painting: 像素绘制页面</li></ul></li></ul><ul><li>缓存策略: 可分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong><ul><li>Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>Cache-Control的 max-age 优先级高于 Expires</strong></li><li>当缓存已经过期时，使用协商缓存<ul><li>唯一标识方案: Etag(response 携带) &amp; If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，</li><li>最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的Last-Modified)<ul><li>如果一致，则直接返回 304 通知浏览器使用缓存</li><li>如不一致，则服务端返回新的资源</li></ul></li></ul></li><li>Last-Modified 缺点：<ul><li>周期性修改，但内容未变时，会导致缓存失效</li><li>最小粒度只到 s， s 以内的改动无法检测到 </li></ul></li><li>Etag 的优先级高于 Last-Modified</li></ul></li></ul><h2 id="重绘与回流"><a aria-hidden="true" href="#重绘与回流"><span class="icon icon-link"></span></a>重绘与回流</h2><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p><ul><li><p><strong>重绘(repaint)</strong>: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 <strong>损耗较少</strong></p></li><li><p><strong>回流(reflow)</strong>: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作: </p><ul><li>页面初次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸、位置、内容发生改变</li><li>元素字体大小变化</li><li>添加或者删除可见的 dom 元素</li><li>激活 CSS 伪类（例如：:hover）</li><li>查询某些属性或调用某些方法<ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul></li></ul></li></ul><p><strong>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</strong></p><h3 id="最佳实践"><a aria-hidden="true" href="#最佳实践"><span class="icon icon-link"></span></a>最佳实践:</h3><ul><li><p>css</p><ul><li>避免使用<code>table</code>布局</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li></ul></li><li><p>javascript </p><ul><li>避免频繁操作样式，可汇总后统一 <strong>一次修改</strong></li><li>尽量使用<code>class</code>进行样式修改</li><li>减少<code>dom</code>的增删次数，可使用 <strong>字符串</strong> 或者 <code>documentFragment</code> 一次性插入</li><li>极限优化时，修改样式可将其<code>display: none</code>后修改</li><li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 <strong>变量存住</strong></li></ul></li></ul><h2 id="存储"><a aria-hidden="true" href="#存储"><span class="icon icon-link"></span></a>存储</h2><p>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</p><ul><li><p>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</p></li><li><p>持久性存储，可以分为 浏览器端 与 服务器端</p><ul><li>浏览器: <ul><li><code>cookie</code>: 通常用于存储用户身份，登录状态等<ul><li>http 中自动携带， 体积上限为 4K， 可自行设置过期时间</li></ul></li><li><code>localStorage / sessionStorage</code>: 长久储存/窗口关闭删除， 体积限制为 4~5M</li><li><code>indexDB</code> </li></ul></li><li>服务器:<ul><li>分布式缓存 redis</li><li>数据库 </li></ul></li></ul></li></ul><h3 id="cookie属性"><a aria-hidden="true" href="#cookie属性"><span class="icon icon-link"></span></a>cookie属性</h3><p>name字段为一个cookie的名称。 value字段为一个cookie的值。</p><p>domain字段为可以访问此cookie的域名。</p><p>非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。</p><p>顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。</p><p>二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。 顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。</p><p>path字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。</p><p>expires/Max-Age 字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</p><p>Size字段 此cookie大小。</p><p>http字段  cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。</p><p>secure 字段 设置是否只能通过https来传递此条cookie</p><h2 id="缓存"><a aria-hidden="true" href="#缓存"><span class="icon icon-link"></span></a>缓存</h2><p>浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。</p><p>浏览器缓存的优点有：</p><p>1.减少了冗余的数据传输，节省了网费</p><p>2.减少了服务器的负担，大大提升了网站的性能</p><p>3.加快了客户端加载网页的速度</p><p>浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。</p><p>1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;</p><p>2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p><p>两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。</p><p>缓存中header的参数：</p><h3 id="强制缓存"><a aria-hidden="true" href="#强制缓存"><span class="icon icon-link"></span></a>强制缓存</h3><p>Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。</p><p><strong>Cache-Control：</strong>当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>cache-control除了该字段外，还有下面几个比较常用的设置值：</p><p><strong>-no-cache：</strong>不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p><p><strong>-no-store：</strong>直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p><p><strong>-public：</strong>可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p><p><strong>-private：</strong>只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p><h3 id="协商缓存"><a aria-hidden="true" href="#协商缓存"><span class="icon icon-link"></span></a>协商缓存</h3><p>Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存</p><p><strong>Etag：</strong>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。</p><p><strong>If-None-Match：</strong>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；</p><p>ETag和Last-Modified的作用和用法，他们的区别：</p><p>1.Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；</p><p>2.在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；</p><p>3.在优先级上，服务器校验优先考虑Etag。</p><h3 id="浏览器缓存过程"><a aria-hidden="true" href="#浏览器缓存过程"><span class="icon icon-link"></span></a>浏览器缓存过程</h3><p>1.浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</p><p>2.下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求</p><p>3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；</p><p>4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；；</p><p>3.常见问题</p><p>用户行为对浏览器缓存的影响</p><p>4.解决方案</p><p>点击刷新按钮或者按F5</p><p>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match,这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.</p><p>用户按Ctrl+F5（强制刷新）</p><p>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.</p><p>地址栏回车</p><p>浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容</p><h2 id="web-worker"><a aria-hidden="true" href="#web-worker"><span class="icon icon-link"></span></a>Web Worker</h2><p>现代浏览器为<code>JavaScript</code>创造的 <strong>多线程环境</strong>。可以新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 <strong>独立运行，互不干扰</strong>，可通过自带的 <strong>消息机制</strong> 相互通信。</p><p><strong>基本用法:</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button title="" type="button" class="__dumi-default-icon __dumi-default-btn-copy __dumi-default-code-block-copy-btn" data-clipboard-text="// 创建 worker
const worker = new Worker(&#x27;work.js&#x27;);

// 向主进程推送消息
worker.postMessage(&#x27;Hello World&#x27;);

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log(&#x27;Received message &#x27; + event.data);
}
" data-status="copy"></button><div class="token-line"><span class="token comment">// 创建 worker</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> worker </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">new</span><span class="token plain"> </span><span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">&#x27;work.js&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 向主进程推送消息</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">worker</span><span class="token punctuation">.</span><span class="token method function property-access">postMessage</span><span class="token punctuation">(</span><span class="token string">&#x27;Hello World&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment">// 监听主进程来的消息</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">worker</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onmessage</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&#x27;Received message &#x27;</span><span class="token plain"> </span><span class="token operator">+</span><span class="token plain"> event</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><strong>限制:</strong></p><ul><li>同源限制</li><li>无法使用 <code>document</code> / <code>window</code> / <code>alert</code> / <code>confirm</code></li><li>无法加载本地资源</li></ul><h2 id="跨标签页通讯"><a aria-hidden="true" href="#跨标签页通讯"><span class="icon icon-link"></span></a>跨标签页通讯</h2><p>不同标签页间的通讯，本质原理就是去运用一些可以 <strong>共享的中间介质</strong>，因此比较常用的有以下方法:</p><ul><li><p>通过父页面<code>window.open()</code>和子页面<code>postMessage</code></p><ul><li>异步下，通过 <code>window.open(&#x27;about: blank&#x27;)</code> 和 <code>tab.location.href = &#x27;*&#x27;</code> </li></ul></li><li><p>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code></p><ul><li>重复写入相同的值无法触发</li><li>会受到浏览器隐身模式等的限制 </li></ul></li><li><p>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</p></li><li><p>借助服务端或者中间层实现</p></li></ul><h2 id="v8垃圾回收机制"><a aria-hidden="true" href="#v8垃圾回收机制"><span class="icon icon-link"></span></a>V8垃圾回收机制</h2><p>垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 <strong>新生代空间</strong> 和 <strong>老生代空间</strong>。</p><ul><li><strong>新生代空间</strong>: 用于存活较短的对象<ul><li>又分成两个空间: from 空间 与 to 空间 </li><li>Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法<ul><li>存活的对象从 from space 转移到 to space</li><li>清空 from space</li><li>from space 与 to space 互换</li><li>完成一次新生代GC</li></ul></li></ul></li><li><strong>老生代空间</strong>: 用于存活时间较长的对象<ul><li>从 新生代空间 转移到 老生代空间 的条件<ul><li>经历过一次以上 Scavenge GC 的对象</li><li>当 to space 体积超过25%</li></ul></li><li><strong>标记清除算法</strong>: 标记存活的对象，未被标记的则被释放<ul><li>增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能</li><li>并发标记(最新技术): 不阻塞 js 执行</li></ul></li><li><strong>压缩算法</strong>: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 <strong>内存的碎片化</strong></li></ul></li></ul><h2 id="内存泄露"><a aria-hidden="true" href="#内存泄露"><span class="icon icon-link"></span></a>内存泄露</h2><ul><li>意外的<strong>全局变量</strong>: 无法被回收</li><li><strong>定时器</strong>: 未被正确关闭，导致所引用的外部变量无法被释放</li><li><strong>事件监听</strong>: 没有正确销毁 (低版本浏览器可能出现)</li><li><strong>闭包</strong>: 会导致父级中的变量无法被释放</li><li><strong>dom 引用</strong>: dom 元素被删除时，内存中的引用未被正确清空</li></ul><p>可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。</p><p>参考<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener noreferrer">How browsers work<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><span data-updated-text="Last Update: ">8/4/2020, 1:05:50 PM</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/umi.js"></script>
  </body>
</html>
